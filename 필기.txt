-----------------기본 설정
react.min.js 파일안에는 컴포넌트 담당 react-dom-min.js 파일안에는 실제 돔에 렌더링하는 부분 담당

-----------------class 
자바스크립트 class 안에서는 메소드만 만들 수 있다.
static 메소드는 객체생성전에도 사용가능

-----------------JSX
컨테이너 element로 꼭 감싸줘야함
JSX안에서 자바스크립트 표현시에는 {}로 표현
JSX안에서 스타일 선언 시 - 사용 안됨 background-color -> backgroundColor 이렇게 표현
{/* ~ */} -> 주석 컨테이너 element 안에 주석 사용되야됨 

평상시 변수 선언 시 let 사용 
let은 한번 선언되면 다시 선언할 수 없음, 블록 유효범위

------------------- props
컴포넌트 내부의 immutable data -> 변하지 않는 데이터 처리 시 사용 
jsx 내부에 {this.props.propsName}
컴포넌트를 사용할 때, <> 안에 propsName="value"
this.props.children은 기본적으로 갖고있는 props로서, <Cpnt>여기에 있는 값이 들어간다.</Cpnt>

컴포넌트 선언이 끝난 후 props 
기본 값 설정 Component.defaultProps = {...}
타입 검증 Component.propTypes = {...}

-----------------state
유동적인 데이터
JSX 내부에 {this.state.stateName}
초기값 설정이 필수, 생성자에서 this.state = {} 으로 설정
값을 수정 할 때에는 this.setState({..}), 렌더링 된 다음에 this.state= 절대 사용하지 말것

-----------------컴포넌트 매핑 
arr.map(콜백함수,..~) 파라미터로 전달 된 함수를 통하여 배열 내의 각 요소를 처리해서 그 결과로 새로운 배열을 생성

-----------------sort()
유니코드로 비교함 
숫자비교시 콜백함수 집어넣어줘야함 
기존배열 바꿈

function comparenumbers(a,b) {
  return a-b;
} //오름차순 

function comparenumbers(a,b) {
  return (a-b) * -1;
} // 내림차순
scores.sort(comparenumbers);


-----------------filter() 
파라미터로 넘어온 함수에 만족되는 값만 정해서 새로운 배열 만듬

-----------------create-react-app에 react-hot-loader 적용하기
create-react-app에는 react-hot-loader를 따로 추가해주어야한다.
react-hot-loader : 리로딩될 때 로컬state가 유지되지 않음 hot-loader 추가하면 유지됨
create-react-app myProject 
-> npm run eject(현재 프로젝트의 모든 설정/스크립트를 내 프로젝트에 옮겨줌. 커스트마이징 가능)
eject를 하기 전에는 설정들이 모두 내부에 숨겨져있지만 eject를 하고 난 이후에는 설정파일들이 외부로 노출되어 자유롭게 커스터마이징을 할 수 있게 된다.
->npm install --save-dev react-hot-loader@next
나머지 설정들 https://ahribori.com/article/590145a95cab3c0c649bdbbf ->참고해

-----------------immutability Helper
state 내부 배열을 처리하는 방법, 객체나 배열을 조금 더 쉽게 수정할 수 있게 해줌
npm install --save react-addons-update
import update from "react-addons-update";
Immutable.js 또한 페이스북에서 만든 라이브러리이며, 이 라이브러리의 일부 기능들을 사용 할 수 있게 한 React addons 이 바로Immutability Helper
//원소 추가
this.setState({
  list : update(
    this.state.list, //첫번째 파라미터 -> 처리할 객체나 배열
    $push: [newObj, newObj2] //두번째 파라미터 -> 처리명령을 지니고 있는 객체, 객체하나만 추가할 때도 []로 감싸야함 
  )
});

//원소 제거
this.setState({
  list : update(
    this.state.list, //처리할 객체나 배열
  {
    $splice: [[index,1], [...]] //list배열의 index부터 시작해서 1개 제거한다는 의미, [[],[],~] 이런 식으로 배열의 배열로 전달해야됨 이런식으로 한개 이상 지울 수 있음 
  } 
  )
});

//원소 수정
this.setState({
  list : update(
    this.state.list, //처리할 객체나 배열
    {
      [index] : { //만약 객체면 index대신에 그 객체의 key가 들어감
        field : {$set:"value"},
        field2 : {$set: "value2"}
      }
    }
  )
});

-----------------spread연산자
npm install --save babel-preset-stage-0 이거 설치하고 webpack.config에도 추가해야됨 -> 검색해보기

ES6 지원
let object = {
  a: '1',
  b: {
    c: '2',
    d: '3',
    e: {
      change_this_value : '0',
      this_stays_smae : '4'
    }
  }
};

let changed = {
  ...object, //spread연산자
  b: {
    ...object.b, //spread연산자
    e: {
      ...object.b.e, //spread연산자
      change_this_value : '5' --> 0->5 값 바뀜 
    }
  }
};

let array = [1,2,3,4,5,6];
let changed = [...array.slice(0,2) ]; //[1,2] slice()는 특정인덱스에서 특정인덱스 전까지의 값을 불러옴

-----------------props type 확인 
%props type과 defaultProps 설정 하는 것 습관들이면 좋다
npm install --save prop-types

import PropTypes from 'prop-types';
App.propTypes = {
  title: PropType.string,
  author: PropType.string.isRequired, //필수적으로 요구하는 값
  onSubmit: PropType.func
}

-----------------LifeCycle API
1.componentWillMount -> 렌더링 되기 전 , 여기서 돔 처리 할 수 없음
2.componentDidMount -> 렌더링된 다음, 돔 처리 가능
3.componentWillReceiveProps -> 새로운 props 받았을 때 ,setState 사용 가능
4.shouldComponentUpdate -> props/state가 변경되었을 때 리렌더링을 할지말지 정한다. 실제 사용 시 비교하고 값 반환 해야함
5.componentWillUpdate -> 컴포넌트 업데이트 전, setState 절대 사용 금지(무한루프에 빠짐)
6.componentDidUpdate  -> 컴포넌트 업데이트 다음, setState 사용 금지
7.componentWillUnMount -> 컴포넌트 제거될 때

-----------------localStorage
html5부터 지원되는 데이터 저장공간 기능,데이터를 새로고침하거나 브라우저를 껏다 켜도 유지할 수 있게
쿠키랑 비슷한 데 저장용량 더 큼, localStorage는 서버로 전송되지 않는다.
text형태로 밖에 저장못함 따라서 JSON.stringify(객체)로 변환 후 저장
다시 꺼내 쓸 때는 JSON.parse() string을 다시 객체로
localStorage.clear -> 초기화 크롬개발자도구에서도 실행가능함 

--------Redux
React 어플리케이션에서 state 관리를 할 때 사용되는 라이브러리

--------Reducer
변화를 일으키는 함수 , 이전상태와 액션을 받아서 다음상태를 반환한다.
이전상태를 변경하는게 아님 그저 새로운 상태를 반환하는 것 -> 기존 상태를 복사하고 변화를 준다음에 반환
action 객체를 처리하는 함수를 reducer라고 부름
reducer은 정보를 받아서 상태를 어떻게 업데이트 할 지 정의
reducer은 '순수 함수'로 작성되어야 함 -> 네트워크 및 데이터베이스 접근 안됨, 인수 변경 안됨, 순수하지 않은 API 사용 불가(Data.now(),Math.random() 등)
                                      같은 인수로 실행된 함수는 언제나 같은 결과를 반환
store는 단 하나만 존재, reducer은 한개 또는 여러개 존재가능 
리듀서 한개일 경우 그 리듀서가 루트 리듀서, 여러개 있을 경우 여러개를 관리하는 리듀서가 루트 리듀서

---------뷰:똑똑한 컴포넌트, 멍청한 컴포넌트
Contact 컴포넌트에 비유하면 Contact컴포넌트는 똑똑한, ContactCreate/ContactDetails는 멍청한 컴포넌트이다.
똑똑한 -> 액션처리 책임, 자신의 스타일,dom 가지지 않음 
멍청한 -> 액션에 의존성 가지지 않고 props 통해서 액션 전달받아서 사용함, 똑똑한 컴포넌트 대신 자신의 스타일,dom 가짐
뷰 레이어 바인딩 : store를 view에 연동시킬 때 뷰 레이어 바인딩 필요(없어도 되지만 사용하면 편리), 리액트에서 리덕스 사용 시 좀 더 쉽게 컴포넌트 스토어에 연결시켜줌
루트 컴포넌트: 리듀스의 기본적인 설정을 담당 그 외 할일 없음 그닥 
http://bestalign.github.io/2015/10/26/cartoon-intro-to-redux/ -> 참고

npm install --save redux react-redux -> react-redux가 뷰 레이어 바인딩임

----------ESLint 패키지
자바스크립트 문법 검사하는 거

---------------Action
작업에 대한 정보를 지니고있는 객체 
Counter 프로젝트에서의 액션은 
1.값 증가시키기 
2.값 감소
3.새로운 색상 설정하기 
액션이름은 대문자와 _ 사용
1.INCREMENT
2.DECREMENT
3.SET_COLOR
액션 객체 모습
액션객체가 필수로 가지고 있어야 하는건 type(액션 객체의 종류)
{type  : "INCREMENT"}
{type  : "DECREMENT"}
{
  type  : "SET_COLOR"
  color : [200,200,200] 
}
이렇게 매번 액션객체 생성하기 귀찮음 -> 액션객체생성자 함수 사용(action/index.js에 작성)
액션생성자는 만든 액션 이름을 camelCase 즉, 소문자로 작성하고 각 사용단어는 대문자화 하는 거
액션이 많을 경우 여러파일로 분리해서 파일만듬


-----------------store
store는 어필리케이션의 현재상태를 지니고있음
스토어 만들기 : 리덕스에서 createStore(리듀서)
store 하는일 : 1. dispatch(action) 액션을 리듀서로 보낸다. 
              2. getState() 현재상태반환
              3. subscribe(listener) 상태가 바뀔때마다 실행할 함수 등록 listener가 콜백함수

---------------------react-redux
뷰 레이어 바인딩도구 리액트에서 리덕스 사용할 때 복잡한 작업 얘가 다해줌 
Provider : 하나의 컴포넌트 컴포넌트에서 리덕스를 사용하도록 서비스 제공해줌
connect([...options]) : 전달받은 옵션을 사용해서 컴포넌트를 리덕스에 연결하는 또 다른!!! 함수를 반환합니다.
connect()(Counter) :반환된 함수의 인자로 counter전달해주면 counter가 리덕스에 연결되서 이 함수의 반환값으로 store에 연결 된 새로운 컴포넌트 클래스가 반환됨 옵션이 없으면 this.props.store로 접근 가능
